{
  "contractName": "LibDiamondCut",
  "sourceName": "solc_0.7/diamond/libraries/LibDiamondCut.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_init",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "DiamondCut",
      "type": "event"
    }
  ],
  "bytecode": "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122044c88b6d5377e64e7ed98bfc5a975cb648a780974d6c1552d4dad7263a3dc31c64736f6c63430007010033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122044c88b6d5377e64e7ed98bfc5a975cb648a780974d6c1552d4dad7263a3dc31c64736f6c63430007010033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "bytecode": {
      "linkReferences": {},
      "opcodes": "PUSH1 0x56 PUSH1 0x23 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x16 JUMPI INVALID JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 DIFFICULTY 0xC8 DUP12 PUSH14 0x5377E64E7ED98BFC5A975CB648A7 DUP1 SWAP8 0x4D PUSH13 0x1552D4DAD7263A3DC31C64736F PUSH13 0x63430007010033000000000000 ",
      "sourceMap": "462:5649:10:-:0;;;;;;;;;;;;;;;;;;;;;;;;;"
    },
    "deployedBytecode": {
      "immutableReferences": {},
      "linkReferences": {},
      "opcodes": "PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 DIFFICULTY 0xC8 DUP12 PUSH14 0x5377E64E7ED98BFC5A975CB648A7 DUP1 SWAP8 0x4D PUSH13 0x1552D4DAD7263A3DC31C64736F PUSH13 0x63430007010033000000000000 ",
      "sourceMap": "462:5649:10:-:0;;;;;;;;"
    },
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "17200",
        "executionCost": "97",
        "totalCost": "17297"
      },
      "internal": {
        "addSelector(address,bytes4)": "infinite",
        "diamondCut(struct IDiamondCut.FacetCut memory[] memory)": "infinite",
        "hasContractCode(address,string memory)": "infinite",
        "removeSelector(bytes4)": "infinite"
      }
    },
    "methodIdentifiers": {}
  },
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solc_0.7/diamond/libraries/LibDiamondCut.sol\":\"LibDiamondCut\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"solc_0.7/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x19c92fe16028a8e74a5f1914235b3e7f4e5eafbc5fced9fa345cab5cd4644c0c\",\"license\":\"MIT\"},\"solc_0.7/diamond/libraries/LibDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n*\\n* Implementation of internal diamondCut function.\\n/******************************************************************************/\\n\\nimport \\\"./LibDiamondStorage.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamondCut {\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Non-standard internal function version of diamondCut\\n    // This code is almost the same as externalCut, except it is using\\n    // 'FacetCut[] memory _diamondCut' instead of 'FacetCut[] calldata _diamondCut'\\n    // and it DOES issue the DiamondCut event\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes a Solidity error for a two dimensional array.\\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            address newFacetAddress = _diamondCut[facetIndex].facetAddress;\\n            // add or replace function\\n            if (newFacetAddress != address(0)) {\\n                uint256 facetAddressPosition = ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition;\\n                // add new facet address if it does not exist\\n                if (facetAddressPosition == 0 && ds.facetFunctionSelectors[newFacetAddress].functionSelectors.length == 0) {\\n                    hasContractCode(newFacetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n                    facetAddressPosition = ds.facetAddresses.length;\\n                    ds.facetAddresses.push(newFacetAddress);\\n                    ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n                }\\n                // add or replace selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    bytes4 selector = _diamondCut[facetIndex].functionSelectors[selectorIndex];\\n                    address oldFacet = ds.selectorToFacetAndPosition[selector].facetAddress;\\n                    // add\\n                    if (oldFacet == address(0)) {\\n                        addSelector(newFacetAddress, selector);\\n                    } else {\\n                        // replace\\n                        if (oldFacet != newFacetAddress) {\\n                            removeSelector(selector);\\n                            addSelector(newFacetAddress, selector);\\n                        }\\n                    }\\n                }\\n            } else {\\n                // remove selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    removeSelector(_diamondCut[facetIndex].functionSelectors[selectorIndex]);\\n                }\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, address(0), new bytes(0));\\n    }\\n\\n    function addSelector(address _newFacet, bytes4 _selector) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        uint256 selectorPosition = ds.facetFunctionSelectors[_newFacet].functionSelectors.length;\\n        ds.facetFunctionSelectors[_newFacet].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _newFacet;\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = uint16(selectorPosition);\\n    }\\n\\n    function removeSelector(bytes4 _selector) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        address oldFacet = ds.selectorToFacetAndPosition[_selector].facetAddress;\\n        // if function does not exist then do nothing and return\\n        if (oldFacet == address(0)) {\\n            return;\\n        }\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[oldFacet].functionSelectors.length - 1;\\n        bytes4 lastSelector = ds.facetFunctionSelectors[oldFacet].functionSelectors[lastSelectorPosition];\\n        // if not the same then replace _selector with lastSelector\\n        if (lastSelector != _selector) {\\n            ds.facetFunctionSelectors[oldFacet].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[oldFacet].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[oldFacet].facetAddressPosition;\\n            if (oldFacet != lastFacetAddress) {\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[oldFacet];\\n        }\\n    }\\n\\n    function hasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x4592963c6aea94140094f170c6502657b5e35ddcc63c67ac5af06aa70a5b589b\",\"license\":\"MIT\"},\"solc_0.7/diamond/libraries/LibDiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selector to the facet address and        \\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe775d2cb83a52f9bc6341b6331acd86527a7870dca3193cfcad3db6206017ed2\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"solc_0.7/diamond/Diamantaire.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IDiamondCut.sol\\\";\\nimport \\\"./Diamond.sol\\\";\\n\\ncontract Diamantaire {\\n    event DiamondCreated(Diamond diamond);\\n\\n    function createDiamond(\\n        address owner,\\n        IDiamondCut.FacetCut[] calldata _diamondCut,\\n        bytes calldata data,\\n        bytes32 salt\\n    ) external payable returns (Diamond diamond) {\\n        Diamond.DiamondArgs memory args;\\n        args.owner = address(this);\\n\\n        if (salt != 0x0000000000000000000000000000000000000000000000000000000000000000) {\\n            salt = keccak256(abi.encodePacked(salt, owner));\\n            diamond = new Diamond{value: msg.value, salt: salt}(_diamondCut, args);\\n        } else {\\n            diamond = new Diamond{value: msg.value}(_diamondCut, args);\\n        }\\n        emit DiamondCreated(diamond);\\n\\n        IDiamondCut(address(diamond)).diamondCut(_diamondCut, data.length > 0 ? address(diamond) : address(0), data);\\n        IERC173(address(diamond)).transferOwnership(owner);\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IDiamondCut.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\n    },\n    \"solc_0.7/diamond/Diamond.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport \\\"./libraries/LibDiamond.sol\\\";\\nimport \\\"./interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"./interfaces/IDiamondCut.sol\\\";\\nimport \\\"./interfaces/IERC173.sol\\\";\\nimport \\\"./interfaces/IERC165.sol\\\";\\n\\ncontract Diamond {\\n    // more arguments are added to this struct\\n    // this avoids stack too deep errors\\n    struct DiamondArgs {\\n        address owner;\\n    }\\n\\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, DiamondArgs memory _args) payable {\\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\\n        LibDiamond.setContractOwner(_args.owner);\\n\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        // adding ERC165 data\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }    \\n}\\n\"\n    },\n    \"solc_0.7/diamond/libraries/LibDiamond.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* This is gas optimized by reducing storage reads and storage writes.\\n* This code is as complex as it is to reduce gas costs.\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // owner of the contract\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n        _;\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            uint256 selectorSlotCount = _selectorCount / 8;\\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n                selectorInSlotIndex--;\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IDiamondLoupe.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IERC173.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\n    },\n    \"solc_0.7/diamond/interfaces/IERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\n    },\n    \"solc_0.7/diamond/facets/DiamondLoupeFacet.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n    // Diamond Loupe Functions\\n    ////////////////////////////////////////////////////////////////////\\n    /// These functions are expected to be called frequently by tools.\\n    //\\n    // struct Facet {\\n    //     address facetAddress;\\n    //     bytes4[] functionSelectors;\\n    // }\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external override view returns (Facet[] memory facets_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facets_ = new Facet[](ds.selectorCount);\\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\\n        uint256 numFacets;\\n        uint256 selectorIndex;\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\\n            bytes32 slot = ds.selectorSlots[slotIndex];\\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\\n                selectorIndex++;\\n                if (selectorIndex > ds.selectorCount) {\\n                    break;\\n                }\\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\\n                bool continueLoop = false;\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\\n                        // probably will never have more than 256 functions from one facet contract\\n                        require(numFacetSelectors[facetIndex] < 255);\\n                        numFacetSelectors[facetIndex]++;\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n                if (continueLoop) {\\n                    continueLoop = false;\\n                    continue;\\n                }\\n                facets_[numFacets].facetAddress = facetAddress_;\\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\\n                facets_[numFacets].functionSelectors[0] = selector;\\n                numFacetSelectors[numFacets] = 1;\\n                numFacets++;\\n            }\\n        }\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\n            // setting the number of selectors\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n        // setting the number of facets\\n        assembly {\\n            mstore(facets_, numFacets)\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 numSelectors;\\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\\n        uint256 selectorIndex;\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\\n            bytes32 slot = ds.selectorSlots[slotIndex];\\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\\n                selectorIndex++;\\n                if (selectorIndex > ds.selectorCount) {\\n                    break;\\n                }\\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\\n                address facet = address(bytes20(ds.facets[selector]));\\n                if (_facet == facet) {\\n                    _facetFunctionSelectors[numSelectors] = selector;\\n                    numSelectors++;\\n                }\\n            }\\n        }\\n        // Set the number of selectors in the array\\n        assembly {\\n            mstore(_facetFunctionSelectors, numSelectors)\\n        }\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddresses_ = new address[](ds.selectorCount);\\n        uint256 numFacets;\\n        uint256 selectorIndex;\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\\n            bytes32 slot = ds.selectorSlots[slotIndex];\\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\\n                selectorIndex++;\\n                if (selectorIndex > ds.selectorCount) {\\n                    break;\\n                }\\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\\n                bool continueLoop = false;\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n                if (continueLoop) {\\n                    continueLoop = false;\\n                    continue;\\n                }\\n                facetAddresses_[numFacets] = facetAddress_;\\n                numFacets++;\\n            }\\n        }\\n        // Set the number of facet addresses in the array\\n        assembly {\\n            mstore(facetAddresses_, numFacets)\\n        }\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\\n    }\\n\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return ds.supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/facets/OwnershipFacet.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\";\\n\\ncontract OwnershipFacet is IERC173 {\\n    function transferOwnership(address _newOwner) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.setContractOwner(_newOwner);\\n    }\\n\\n    function owner() external override view returns (address owner_) {\\n        owner_ = LibDiamond.contractOwner();\\n    }\\n}\"\n    },\n    \"solc_0.7/diamond/facets/DiamondCutFacet.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract DiamondCutFacet is IDiamondCut {    \\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        LibDiamond.initializeDiamondCut(_init, _calldata);\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/libraries/LibDiamondCut.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n*\\n* Implementation of internal diamondCut function.\\n/******************************************************************************/\\n\\nimport \\\"./LibDiamondStorage.sol\\\";\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamondCut {\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Non-standard internal function version of diamondCut\\n    // This code is almost the same as externalCut, except it is using\\n    // 'FacetCut[] memory _diamondCut' instead of 'FacetCut[] calldata _diamondCut'\\n    // and it DOES issue the DiamondCut event\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes a Solidity error for a two dimensional array.\\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            address newFacetAddress = _diamondCut[facetIndex].facetAddress;\\n            // add or replace function\\n            if (newFacetAddress != address(0)) {\\n                uint256 facetAddressPosition = ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition;\\n                // add new facet address if it does not exist\\n                if (facetAddressPosition == 0 && ds.facetFunctionSelectors[newFacetAddress].functionSelectors.length == 0) {\\n                    hasContractCode(newFacetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n                    facetAddressPosition = ds.facetAddresses.length;\\n                    ds.facetAddresses.push(newFacetAddress);\\n                    ds.facetFunctionSelectors[newFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n                }\\n                // add or replace selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    bytes4 selector = _diamondCut[facetIndex].functionSelectors[selectorIndex];\\n                    address oldFacet = ds.selectorToFacetAndPosition[selector].facetAddress;\\n                    // add\\n                    if (oldFacet == address(0)) {\\n                        addSelector(newFacetAddress, selector);\\n                    } else {\\n                        // replace\\n                        if (oldFacet != newFacetAddress) {\\n                            removeSelector(selector);\\n                            addSelector(newFacetAddress, selector);\\n                        }\\n                    }\\n                }\\n            } else {\\n                // remove selectors\\n                for (uint256 selectorIndex; selectorIndex < _diamondCut[facetIndex].functionSelectors.length; selectorIndex++) {\\n                    removeSelector(_diamondCut[facetIndex].functionSelectors[selectorIndex]);\\n                }\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, address(0), new bytes(0));\\n    }\\n\\n    function addSelector(address _newFacet, bytes4 _selector) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        uint256 selectorPosition = ds.facetFunctionSelectors[_newFacet].functionSelectors.length;\\n        ds.facetFunctionSelectors[_newFacet].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _newFacet;\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = uint16(selectorPosition);\\n    }\\n\\n    function removeSelector(bytes4 _selector) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n        address oldFacet = ds.selectorToFacetAndPosition[_selector].facetAddress;\\n        // if function does not exist then do nothing and return\\n        if (oldFacet == address(0)) {\\n            return;\\n        }\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[oldFacet].functionSelectors.length - 1;\\n        bytes4 lastSelector = ds.facetFunctionSelectors[oldFacet].functionSelectors[lastSelectorPosition];\\n        // if not the same then replace _selector with lastSelector\\n        if (lastSelector != _selector) {\\n            ds.facetFunctionSelectors[oldFacet].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[oldFacet].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[oldFacet].facetAddressPosition;\\n            if (oldFacet != lastFacetAddress) {\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[oldFacet];\\n        }\\n    }\\n\\n    function hasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\n    },\n    \"solc_0.7/diamond/libraries/LibDiamondStorage.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // owner of the contract\\n        address contractOwner;\\n        // maps function selector to the facet address and        \\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 2000\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
  "solcInputHash": "1c35ae96eec04f819b95dcb93c58bdda"
}